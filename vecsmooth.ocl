kernel void init(
	global int * restrict v1,
	int nels)
{
	int i = get_global_id(0);
	if (i >= nels)
		return;
	v1[i] = i;
}

kernel void smooth(
	global int * restrict vsmooth,
	global const int * restrict v1,
	int nels)
{
	int i = get_global_id(0);
	if (i >= nels)
		return;

	int count = 0;
	int val = 0;

	if (i > 0) {
		val += v1[i - 1];
		count++;
	}
	val += v1[i];
	count++;
	if (i < nels - 1) {
		val += v1[i + 1];
		count++;
	}
	vsmooth[i] = val/count;
}

kernel void smooth_lmem(
	global int * restrict vsmooth,
	global const int * restrict v1,
	/* local memory che usiamo come cache. Un work-group con local
	   size lws ha bisogno di lws+2 elementi */
	local int * cache,
	int nels)
{

	const int i = get_global_id(0);

	/* prima fase: lettura dalla global alla local memory */

	/* indice del work-item nel work-group */
	const int li = get_local_id(0);
	if (i < nels)
		cache[li+1] = v1[i];
	if (li == 0 && i > 0)
		cache[0] = v1[i-1];
	if (li == get_local_size(0) - 1 && i < nels -1)
		cache[li+2] = v1[i+1];

	/* seconda fase: smoothing usando la local memory */
	int val = cache[li+1];
	int count = 1;

	/* prima di leggere i dati a sx e dx, aspetto
	   che tutti abbiamo letto in lmem i dati */
	barrier(CLK_LOCAL_MEM_FENCE);

	if (i > 0) {
		val += cache[li]; // elemento precedente
		count++;
	}
	if (i < nels - 1) {
		val += cache[li + 2];
		count++;
	}

	if (i < nels)
		vsmooth[i] = val/count;
}