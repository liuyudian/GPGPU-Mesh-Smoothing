#define INDEX_BITS 26
#define COUNT_BITS 6

kernel void smooth(
	global float4 * restrict vertex4_array,
	global unsigned int * restrict adjs_array,
	global float4 * restrict result_vertex4_array,
	unsigned int nels, float factor)
{	
	unsigned int i = get_global_id(0);
	if(i >= nels) return;
	
	float4 vertex = vertex4_array[i];
	float lastComponent = vertex.w;
	
	unsigned int adjsInfo = *(unsigned int *)&lastComponent;
	unsigned int adjsIndexOffset = adjsInfo>>COUNT_BITS;
	unsigned int adjsCount = ((adjsInfo)<<INDEX_BITS)>>INDEX_BITS;
	//printf("vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, vertex.x, vertex.y, vertex.z, adjsIndexOffset, adjsCount);
	
	float4 umbrellaOperator = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
	for(int adjIndex=0; adjIndex<adjsCount; adjIndex++)
	{
		float4 adj = vertex4_array[adjs_array[adjsIndexOffset+adjIndex]];
		umbrellaOperator += ( adj-vertex );
		//printf("Adj %d of %d -> %f / %f / %f\n", adjIndex, i, adj.x, adj.y, adj.z);
	}
	umbrellaOperator /= adjsCount;
	float4 res = vertex + factor*umbrellaOperator;
	res.w = lastComponent;
	result_vertex4_array[i] = res;
	//printf("result vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, res.x, res.y, res.z, adjsIndexOffset, adjsCount);
}

kernel void smooth_coalescence(
	global float4 * restrict vertex4_array,
	global unsigned int * restrict adjs_array,
	global float4 * restrict result_vertex4_array,
	unsigned int nels, float factor)
{	
	unsigned int i = get_global_id(0);
	if(i >= nels) return;
	
	float4 vertex = vertex4_array[i];
	float lastComponent = vertex.w;
	
	unsigned int adjsInfo = *(unsigned int *)&lastComponent;
	unsigned int adjsIndexOffset = adjsInfo>>COUNT_BITS;
	unsigned int adjsCount = ((adjsInfo)<<INDEX_BITS)>>INDEX_BITS;
	//printf("vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, vertex.x, vertex.y, vertex.z, adjsIndexOffset, adjsCount);
	
	float4 umbrellaOperator = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
	for(int adjIndex=0; adjIndex<adjsCount; adjIndex++)
	{
		float4 adj = vertex4_array[adjs_array[adjsIndexOffset+adjIndex]];
		umbrellaOperator += ( adj-vertex );
		//printf("Adj %d of %d -> %f / %f / %f\n", adjIndex, i, adj.x, adj.y, adj.z);
	}
	umbrellaOperator /= adjsCount;
	float4 res = vertex + factor*umbrellaOperator;
	res.w = lastComponent;
	result_vertex4_array[i] = res;
	//printf("result vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, res.x, res.y, res.z, adjsIndexOffset, adjsCount);
}

