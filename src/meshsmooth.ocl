#define INDEX_BITS 26
#define COUNT_BITS 6

kernel void smooth(
	global const float4 * restrict vertex4_array,
	global const unsigned int * restrict adjs_array,
	global float4 * restrict result_vertex4_array,
	unsigned int nels, float factor)
{	
	
	unsigned int i = get_global_id(0);
	if(i >= nels) return;
	if(i==0) printf("\n SMOOTH \n");
	
	float4 vertex = vertex4_array[i];
	
	float lastComponent = vertex.w;
	unsigned int adjsInfo = *(unsigned int *)&lastComponent;
	unsigned int adjsIndexOffset = adjsInfo>>COUNT_BITS;
	unsigned int adjsCount = ((adjsInfo)<<INDEX_BITS)>>INDEX_BITS;
	printf(" vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, vertex.x, vertex.y, vertex.z, adjsIndexOffset, adjsCount);
	
	float4 current_adj, umbrellaOperator = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
	for(int adjIndex=0; adjIndex<adjsCount; adjIndex++)
	{
		current_adj = vertex4_array[adjs_array[adjsIndexOffset+adjIndex]];
		umbrellaOperator += (current_adj - vertex);
		if(i==2)printf("adj index[%d] %d^o adj of vertex %d -> %f / %f / %f\n", adjs_array[adjsIndexOffset+adjIndex], adjIndex+1, i, current_adj.x, current_adj.y, current_adj.z);

	}
	umbrellaOperator /= adjsCount;
	float4 res = vertex + factor*umbrellaOperator;
	res.w = lastComponent;
	result_vertex4_array[i] = res;
}
/*
kernel void smooth_lmem(
	global const float4 * restrict vertex4_array,
	local float4 * restrict local_vertex4_array,
	global const unsigned int * restrict adjs_array,
	global float4 * restrict result_vertex4_array,
	unsigned int nels, float factor)
{	

	const unsigned int i = get_global_id(0);	
	if(i >= nels) return;
	if(i==0) printf("\n SMOOTH LMEM \n");
	
	const unsigned int li = get_local_id(0);
	const unsigned int gi = get_group_id(0);
	
	float4 vertex = vertex4_array[i];
	local_vertex4_array[li] = vertex;
	barrier(CLK_LOCAL_MEM_FENCE);
	

	printf(" %d write in local[%d] -> %f/%f/%f \n", i, li, local_vertex4_array[li]);
	
	float lastComponent = vertex.w;
	unsigned int adjsInfo = *(unsigned int *)&lastComponent;
	unsigned int adjsIndexOffset = adjsInfo>>COUNT_BITS;
	unsigned int adjsCount = ((adjsInfo)<<INDEX_BITS)>>INDEX_BITS;
	
	printf("vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, vertex.x, vertex.y, vertex.z, adjsIndexOffset, adjsCount);
	
	float4 current_adj, umbrellaOperator = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
	unsigned int adj_index;
	for(int adjIndex=0; adjIndex<adjsCount; adjIndex++)
	{
		adj_index = adjs_array[adjsIndexOffset+adjIndex];
		if(adj_index > i-1 && adj_index < i+get_local_size(0)+1) current_adj = local_vertex4_array[adj_index - i]; //read from local memory
		else current_adj = vertex4_array[adj_index]; //read from global memory
		printf("adj index[%d] %d^o adj of vertex %d -> %f / %f / %f\n", adj_index, adjIndex, i, current_adj.x, current_adj.y, current_adj.z);

		
		umbrellaOperator += (current_adj - vertex);
	}
	umbrellaOperator /= adjsCount;
	float4 res = vertex + factor*umbrellaOperator;
	res.w = lastComponent;
	result_vertex4_array[i] = res;
}
*/
kernel void smooth_coalescence(
	global const float4 * restrict vertex4_array,
	global const unsigned int * restrict adjs_array,
	global const unsigned int * restrict adjsCounter_array,
	global float4 * restrict result_vertex4_array,
	unsigned int nels, float factor)
{	
	unsigned int i = get_global_id(0);
	if(i >= nels) return;
	if(i==0) printf("\n SMOOTH COALESCENCE \n");
	
	
	float4 vertex = vertex4_array[i];
	float lastComponent = vertex.w;
	unsigned int adjsCount = *(unsigned int *)&lastComponent;
	printf("vertex %d -> %f / %f / %f   #adj -> %d \n", i, vertex.x, vertex.y, vertex.z, adjsCount);

	float4 current_adj;
	float4 umbrellaOperator = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
	int offset = 0;
	for(int adjIndex=0; adjIndex<adjsCount; adjIndex++)
	{
		current_adj = vertex4_array[adjs_array[i+offset]];
		if(i==0)printf("adj index[%d] %d^o adj of vertex %d -> %f / %f / %f\n", adjs_array[i+offset], adjIndex, i, current_adj.x, current_adj.y, current_adj.z);

		umbrellaOperator += (current_adj - vertex);
		//printf("Adj %d of vertex %d is vertex %d -> %f / %f / %f\n", adjIndex, i, adjs_array[i+offset], current_adj.x, current_adj.y, current_adj.z);
		offset += adjsCounter_array[adjIndex];
		//printf("Adj %d of vertex %d -> %d\n", adjIndex, i, adjs_array[i+offset]);
	}
	umbrellaOperator /= adjsCount; //controllare che non sia un vertice isolato
	float4 res = vertex + factor*umbrellaOperator;
	res.w = lastComponent;
	result_vertex4_array[i] = res;
	//printf("result vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, res.x, res.y, res.z, adjsIndexOffset, adjsCount);
}
/*
kernel void smooth_coalescence_lmem(
	global const float4 * restrict vertex4_array,
	global const unsigned int * restrict adjs_array,
	global const unsigned int * restrict adjsCounter_array,
	local unsigned int * restrict local_adjsCounter_array, const unsigned int adjsCounter_array_dim,
	global float4 * restrict result_vertex4_array,
	unsigned int nels, float factor)
{	

	const unsigned int li = get_local_id(0);
	const unsigned int i = get_global_id(0);
	if(i==0) printf("\n SMOOTH COALESCENCE LMEM\n");
	
	if(li<adjsCounter_array_dim) local_adjsCounter_array[li] = adjsCounter_array[li];
	if(i >= nels) return;
	barrier(CLK_LOCAL_MEM_FENCE);
	
	float4 vertex = vertex4_array[i];
	float lastComponent = vertex.w;
	unsigned int adjsCount = *(unsigned int *)&lastComponent;
	printf("vertex %d -> %f / %f / %f   #adj -> %d \n", i, vertex.x, vertex.y, vertex.z, adjsCount);

	float4 current_adj;
	float4 umbrellaOperator = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
	int offset = 0;
	for(int adjIndex=0; adjIndex<adjsCount; adjIndex++)
	{
		current_adj = vertex4_array[adjs_array[i+offset]];
		printf("adj index[%d] %d^o adj of vertex %d -> %f / %f / %f\n", adjs_array[i+offset], adjIndex, i, current_adj.x, current_adj.y, current_adj.z);
		
		umbrellaOperator += (current_adj - vertex);
		//printf("Adj %d of vertex %d is vertex %d -> %f / %f / %f\n", adjIndex, i, adjs_array[i+offset], current_adj.x, current_adj.y, current_adj.z);
		offset += local_adjsCounter_array[adjIndex];
		//printf("Adj %d of vertex %d -> %d\n", adjIndex, i, adjs_array[i+offset]);
	}
	umbrellaOperator /= adjsCount; //controllare che non sia un vertice isolato
	float4 res = vertex + factor*umbrellaOperator;
	res.w = lastComponent;
	result_vertex4_array[i] = res;
	//printf("result vertex %d -> %f / %f / %f   #offset -> %d  #adj -> %d \n", i, res.x, res.y, res.z, adjsIndexOffset, adjsCount);
}
*/